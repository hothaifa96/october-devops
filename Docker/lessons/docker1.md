# Docker Introduction 


## Part 1: Containers vs Virtual Machines

### Virtual Machines (VMs)
**What is a VM?**
- A complete virtualized computer system with its own operating system
- Runs on top of a hypervisor
- Each VM includes a full OS, binaries, libraries, and applications

**Components:**
- **Host OS**: The operating system running on the physical hardware
- **Hypervisor**: Software layer that creates and manages VMs
  - **Type 1 (Bare Metal)**: Runs directly on hardware (VMware ESXi, Microsoft Hyper-V, KVM)
  - **Type 2 (Hosted)**: Runs on top of host OS (VirtualBox, VMware Workstation)
- **Guest OS**: The operating system running inside each VM
- **Applications**: Run inside the Guest OS

**VM Architecture:**
```
┌─────────────────────────────────────────────┐
│         Applications & Binaries             │
├─────────────────────────────────────────────┤
│            Guest OS (Full OS)               │
├─────────────────────────────────────────────┤
│              Hypervisor                     │
├─────────────────────────────────────────────┤
│              Host OS                        │
├─────────────────────────────────────────────┤
│         Physical Hardware (Server)          │
└─────────────────────────────────────────────┘
```

**Pros:**
- Complete isolation between VMs
- Can run different operating systems simultaneously
- Strong security boundaries

**Cons:**
- Heavy resource consumption (each VM needs full OS)
- Slow startup time (boots entire OS)
- Large storage footprint (GBs per VM)
- Resource overhead for multiple OS kernels

---

### Docker Containers

**What is a Container?**
- Lightweight, standalone executable package
- Includes application code, runtime, libraries, and dependencies
- Shares the host OS kernel
- Isolated from other containers

**Container Architecture:**
```
┌─────────────────────────────────────────────┐
│      Container 1    │    Container 2        │
│  ┌──────────────┐   │  ┌──────────────┐    │
│  │ App + Libs   │   │  │ App + Libs   │    │
│  └──────────────┘   │  └──────────────┘    │
├─────────────────────────────────────────────┤
│          Docker Engine (Daemon)             │
├─────────────────────────────────────────────┤
│              Host OS                        │
├─────────────────────────────────────────────┤
│         Physical Hardware (Server)          │
└─────────────────────────────────────────────┘
```

**Pros:**
- Lightweight (shares host OS kernel)
- Fast startup (seconds)
- Small storage footprint (MBs per container)
- Efficient resource usage
- Easy to scale and deploy
- Consistent across environments

**Cons:**
- Less isolation than VMs
- All containers must use same OS kernel
- Security depends on kernel isolation

---

### Key Differences: VMs vs Containers

| Feature | Virtual Machines | Containers |
|---------|-----------------|------------|
| **Size** | Gigabytes | Megabytes |
| **Startup Time** | Minutes | Seconds |
| **OS** | Each VM has full OS | Share host OS kernel |
| **Isolation** | Complete (hardware-level) | Process-level |
| **Resource Usage** | Heavy | Lightweight |
| **Portability** | Less portable | Highly portable |
| **Use Case** | Running different OS types | Running multiple apps on same OS |

---

## Part 2: Docker Architecture

### Docker Components

**1. Docker Daemon (dockerd)**
- Background service running on the host
- Manages Docker objects (images, containers, networks, volumes)
- Listens for Docker API requests
- Does the heavy lifting of building, running, and managing containers

**2. Docker Client (docker)**
- Command-line tool users interact with
- Sends commands to Docker Daemon via REST API
- Can communicate with remote daemons

**3. Docker Registry (Docker Hub)**
- Repository for Docker images
- Default public registry: hub.docker.com
- Stores and distributes images
- Can be public or private

**4. Docker Objects**
- **Images**: Read-only templates to create containers
- **Containers**: Runnable instances of images
- **Networks**: Enable communication between containers
- **Volumes**: Persist data generated by containers

### Docker Architecture Diagram

```
┌──────────────────────────────────────────────────────┐
│                   Docker Client                       │
│              (CLI: docker commands)                   │
└────────────────────┬─────────────────────────────────┘
                     │ REST API
                     ▼
┌──────────────────────────────────────────────────────┐
│                  Docker Daemon                        │
│                    (dockerd)                          │
│  ┌──────────────────────────────────────────────┐   │
│  │  Container Management                        │   │
│  │  Image Management                            │   │
│  │  Network Management                          │   │
│  │  Volume Management                           │   │
│  └──────────────────────────────────────────────┘   │
└────────────────────┬─────────────────────────────────┘
                     │
                     ▼
┌──────────────────────────────────────────────────────┐
│              Docker Registry (Docker Hub)             │
│          (Stores and distributes images)              │
└──────────────────────────────────────────────────────┘
```

### How Docker Works - The Flow

1. **Developer creates Dockerfile** → Defines application and dependencies
2. **Build image** → `docker build` creates image from Dockerfile
3. **Push to registry** → `docker push` uploads image to Docker Hub
4. **Pull from registry** → `docker pull` downloads image from Docker Hub
5. **Run container** → `docker run` creates container from image
6. **Container runs** → Isolated application instance executes

---

## Part 3: Essential Docker Commands

### Working with Docker Hub

**Docker Hub (hub.docker.com)**
- Official registry for Docker images
- Search for images: https://hub.docker.com/search
- Official images: Maintained by Docker and software vendors
- Community images: Created by users

**Image Naming Convention:**
```
repository/image:tag
```
- **repository**: User or organization name (optional for official images)
- **image**: Image name
- **tag**: Version identifier (default: `latest`)

**Examples:**
- `nginx:latest` - Official Nginx image, latest version
- `nginx:1.21` - Nginx version 1.21
- `ubuntu:20.04` - Ubuntu 20.04
- `mysql:8.0` - MySQL version 8.0
- `username/myapp:v1.0` - Custom user image with tag

### Searching Images on Docker Hub

**Via Website:**
1. Go to hub.docker.com
2. Use search bar to find images
3. Check image details, tags, and documentation
4. Look for official images (verified badge)

**Via Command Line:**
```bash
docker search nginx
docker search mysql
docker search ubuntu
```

---

### Core Docker Commands Covered in Class

### 1. docker pull
**Purpose:** Downloads an image from Docker Hub to your local machine

**Syntax:**
```bash
docker pull [IMAGE_NAME]:[TAG]
```

**Examples:**
```bash
# Pull latest version of nginx
docker pull nginx

# Pull specific version
docker pull nginx:1.21

# Pull Ubuntu 20.04
docker pull ubuntu:20.04

# Pull MySQL 8
docker pull mysql:8.0
```

**What happens:**
- Docker contacts Docker Hub
- Downloads all image layers
- Stores image locally
- Image is now available for creating containers

---

### 2. docker run
**Purpose:** Creates and starts a new container from an image

**Syntax:**
```bash
docker run [OPTIONS] [IMAGE_NAME]:[TAG]
```

**Basic Examples:**
```bash
# Run nginx (downloads image if not available locally)
docker run nginx

# Run in detached mode (background)
docker run -d nginx

# Run with custom name
docker run --name my-nginx nginx

# Run with port mapping (host:container)
docker run -p 8080:80 nginx

# Run interactively with terminal
docker run -it ubuntu bash
```

**Common Options:**
- `-d` or `--detach`: Run in background
- `-p` or `--publish`: Map ports (host_port:container_port)
- `--name`: Give container a custom name
- `-it`: Interactive mode with terminal
- `-e`: Set environment variables
- `-v`: Mount volumes
- `--rm`: Remove container automatically when stopped

**What happens:**
1. Checks if image exists locally
2. If not, pulls from Docker Hub
3. Creates a new container from image
4. Starts the container
5. Returns container ID

---

### 3. docker ps
**Purpose:** Lists containers

**Syntax:**
```bash
docker ps [OPTIONS]
```

**Examples:**
```bash
# Show running containers
docker ps

# Show all containers (running and stopped)
docker ps -a

# Show only container IDs
docker ps -q

# Show last created container
docker ps -l

# Show container sizes
docker ps -s
```

**Output Information:**
- **CONTAINER ID**: Unique container identifier
- **IMAGE**: Image used to create container
- **COMMAND**: Command running in container
- **CREATED**: When container was created
- **STATUS**: Current state (Up, Exited)
- **PORTS**: Port mappings
- **NAMES**: Container name

---

### 4. docker start
**Purpose:** Starts one or more stopped containers

**Syntax:**
```bash
docker start [CONTAINER_ID or CONTAINER_NAME]
```

**Examples:**
```bash
# Start container by name
docker start my-nginx

# Start container by ID
docker start a1b2c3d4

# Start multiple containers
docker start container1 container2

# Start and attach to container
docker start -a my-nginx
```

**Key Points:**
- Only works on **stopped** containers
- Doesn't create new container (unlike `docker run`)
- Container keeps its previous configuration
- Container ID/name remains the same

---

### 5. docker stop
**Purpose:** Stops one or more running containers gracefully

**Syntax:**
```bash
docker stop [CONTAINER_ID or CONTAINER_NAME]
```

**Examples:**
```bash
# Stop container by name
docker stop my-nginx

# Stop container by ID
docker stop a1b2c3d4

# Stop multiple containers
docker stop container1 container2

# Stop all running containers
docker stop $(docker ps -q)
```

**What happens:**
1. Sends SIGTERM signal (graceful shutdown)
2. Waits 10 seconds for container to stop
3. If still running, sends SIGKILL (force stop)

**Key Points:**
- Container is **stopped**, not removed
- Data inside container is preserved
- Can restart with `docker start`
- Use `docker rm` to remove stopped containers

---

## Part 4: Docker Workflow - Putting It All Together

### Typical Development Workflow

**1. Find an Image**
```bash
# Search on Docker Hub website or CLI
docker search nginx
```

**2. Pull the Image**
```bash
# Download image to local machine
docker pull nginx:latest
```

**3. Run a Container**
```bash
# Create and start container
docker run -d -p 8080:80 --name my-web-server nginx
```

**4. Check Running Containers**
```bash
# Verify container is running
docker ps
```

**5. Stop Container**
```bash
# Stop when done
docker stop my-web-server
```

**6. Start Container Again**
```bash
# Restart the same container
docker start my-web-server
```

**7. Remove Container (cleanup)**
```bash
# First stop if running
docker stop my-web-server

# Then remove
docker rm my-web-server
```

---

## Part 5: Practice Exercises

### Exercise 1: Run a Web Server
```bash
# Pull nginx image
docker pull nginx

# Run nginx on port 8080
docker run -d -p 8080:80 --name webserver nginx

# Check if running
docker ps

# Test in browser: http://localhost:8080

# Stop and remove
docker stop webserver
docker rm webserver
```

### Exercise 2: Interactive Ubuntu Container
```bash
# Run Ubuntu interactively
docker run -it --name myubuntu ubuntu bash

# Inside container:
ls
pwd
whoami
exit

# Start again
docker start -i myubuntu

# Remove
docker rm myubuntu
```

### Exercise 3: Working with Different Versions
```bash
# Pull multiple nginx versions
docker pull nginx:1.21
docker pull nginx:latest

# List images
docker images

# Run specific version
docker run -d --name nginx-old nginx:1.21
docker run -d --name nginx-new nginx:latest

# Check both running
docker ps
```

---

## Part 6: Important Concepts to Remember

### Container Lifecycle States
1. **Created**: Container created but not started
2. **Running**: Container is active and running
3. **Paused**: Container processes are paused
4. **Stopped**: Container has stopped
5. **Removed**: Container deleted from system

### Hypervisor Types
- **Type 1 (Bare Metal)**: Runs directly on hardware
  - Examples: VMware ESXi, Microsoft Hyper-V, KVM, Xen
  - Used in production/enterprise environments
  
- **Type 2 (Hosted)**: Runs on host operating system
  - Examples: VirtualBox, VMware Workstation, Parallels
  - Used for development/testing

### Docker Daemon vs Docker Client
- **Daemon**: Backend service doing the work
- **Client**: Frontend CLI you interact with
- Communication: REST API over Unix socket or TCP

### Images vs Containers
- **Image**: Blueprint/template (like a class in OOP)
- **Container**: Running instance (like an object in OOP)
- One image can create multiple containers

---

## Quick Reference Card

### Most Used Commands from This Lesson

```bash
# Search for images
docker search [IMAGE_NAME]

# Pull an image
docker pull [IMAGE_NAME]:[TAG]

# Run a container
docker run -d -p [HOST_PORT]:[CONTAINER_PORT] --name [NAME] [IMAGE]

# List running containers
docker ps

# List all containers
docker ps -a

# Stop a container
docker stop [CONTAINER_NAME/ID]

# Start a stopped container
docker start [CONTAINER_NAME/ID]

# Remove a container
docker rm [CONTAINER_NAME/ID]

# List images
docker images

# Remove an image
docker rmi [IMAGE_NAME/ID]
```

---

## Next Steps for Students

**Practice Tasks:**
1. Pull and run different images (nginx, apache, mysql, redis)
2. Experiment with port mappings
3. Create multiple containers from same image
4. Practice starting and stopping containers
5. Explore Docker Hub for useful images

**Topics for Next Lesson:**
- Docker volumes (data persistence)
- Docker networks (container communication)
- Environment variables
- Docker Compose
- Creating custom images with Dockerfile
- Container logs and debugging

---

## Additional Resources

- **Docker Hub**: https://hub.docker.com
- **Docker Documentation**: https://docs.docker.com
- **Docker CLI Reference**: https://docs.docker.com/engine/reference/commandline/cli/
- **Play with Docker**: https://labs.play-with-docker.com (free online Docker playground)

---
